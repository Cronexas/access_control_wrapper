//Comapre to: github.com/mortepau/tfe4171

//Imports necessary for dataclasses
import tlul_pkg::*;
import ibex_pkg::*;
//Parameters
parameter int unsigned          PMPGranularity = 0;    
parameter int unsigned          PMPNumChan = 1;
parameter int unsigned          PMPNumRegions = 4;
parameter logic[1:0] 		idle = 2'b00;
parameter logic[1:0]		block_start = 2'b01;
parameter logic[1:0]		block_idle = 2'b10;
parameter logic[1:0]		block_err = 2'b11;
//parameter logic[31:0]	go_idle_addr = 32'h000003c1; //961 dec, 32'h03c1 0000
parameter int unsigned 		go_idle_addr = 193;
parameter int unsigned 		return_denied_reg_addr = 194;
parameter int unsigned 		return_denied_reg_type = 195;
parameter int unsigned 		return_current_state = 196;
//parameter enum logic {idle = 1'b0, block = 1'b1};  


module ACW_property_suite(rst,clk,irq_q,tl_h2pmp, tl_pmp2h,tl_d2pmp,tl_pmp2d,tl_cpu2csr, tl_csr2cpu,csr_pmp_cfg,current_state,wr_en_csr, rd_data_csr, activate_cpu_err_resp_q, 
ack_outstanding_q,pmp_req_err, err_rsp_sent_q, go_to_idle_q, go_to_idle_d, cpu_addr_rel, irq_d, tl_err_rsp_device_outstanding, number_bits_a_mask, a_size_int, activate_cpu_err_resp_d,
denied_reg_addr_q, ack_outstanding_d, denied_reg_type_q
);
//All IO of module access_control_wrapper.sv
input logic 				rst;
input logic 				clk;
input logic 				irq_q;
input logic 				irq_d;
input tlul_pkg::tl_h2d_t 		tl_h2pmp;               		//TLUL message untrusted master to wrapper (pmp)
input tlul_pkg::tl_d2h_t 		tl_pmp2h;               	//error response message to untrusted master if permission denied
input tlul_pkg::tl_d2h_t	        tl_d2pmp;                 		//incoming message from device to pmp, gets relayed without change
input tlul_pkg::tl_h2d_t	        tl_pmp2d;               	//send message to device, if permission granted by pmp
input tlul_pkg::tl_h2d_t      		tl_cpu2csr;
input tlul_pkg::tl_d2h_t        	tl_csr2cpu;
input tlul_pkg::tl_d2h_t		tl_err_rsp_device_outstanding;        
//Add additional signals of wrapper here.
input ibex_pkg::pmp_cfg_t		csr_pmp_cfg [PMPNumRegions];
input logic[1:0]			current_state;
input logic				wr_en_csr[4:0];
input logic 				activate_cpu_err_resp_q;
input logic 				activate_cpu_err_resp_d;
input logic 				ack_outstanding_q;
input logic 				pmp_req_err;
input logic 				err_rsp_sent_q;
input logic 				go_to_idle_q;
input logic 				go_to_idle_d;
input logic [31:0]			rd_data_csr[4:0];
input logic [31:0]			denied_reg_addr_q;
input logic [28:0]  			cpu_addr_rel;
input int				number_bits_a_mask;
input int				a_size_int;
input logic 				ack_outstanding_d;
input logic [2:0]			denied_reg_type_q;
//{} 




//For Discussion:
//1)Actual ibex_pmp.sv input csr_pmp_cfg_i is type pmp_cfg_t (see ibex_pkg.sv) 
//1)Each csr consist of 8 Bits. but here are always 32 bit mapped on 6 bits ?
//2)Ask Dino for await_o
`define true 1
`include "tidal.sv"
`begin_tda(ops)
	//
	
	/////////////////////////////////
	// 	PMP Blackbox???(:      //
	////////////////////////////////
	// CSR 5*32 Bits(where First 1*32 is acutal CSR). 4*32 Address
	// for csr packages ibex_csr 
	// wr_en_i: enables write of wr_data_i to register
	// wr_data_i: input data; default 32 bit
	// clk,rst : clock and reset (register set to all 0)
	// rd_data_o: output data; equal to register value.
	// rd_error_o, by default not defined, because shadow is set off.
	// ACATUAL PMP-CSR (in Ibex_pkg only 6 bits defined)
	// We have 4x 8 bit . 8 bit are shown in RISC-V Doc Fig 3.271 CSR[7:0]
	// CSR[7] : Lock write to configuration register and associated addressed register is locked.
	// CSR[6:5] : WIRI->Write Ignored Read Ignored
	// CSR[4:3] : A Adress matching Mode 0: OFF, disabled;1: TOR (TopOfRange);
	// 2:NA4,Naturally alligned 4Byte Region;3:NAPOT,Naturally aligned power-of-two-region >=8 bytes 
	// if entry is set to TOR the previous entry is always treated as lower range.
	// CSR[2] : X instruction execution permit
	// CSR[1] : W: Write permit
	// CSR[0] : R: Read permit
	//=> Pattern A:both values;X:dont care;1/0:specified value only
	//=>AXXA|AAAA the "|" is used for better overview
	// PMP-ADDRESS 4x 32 Bit Register holding address
	// csr_pmp_cfg_i connected to rd_data_o of csr.
	// csr_pmp_addr_i
	//a_data is 32 bit.
	//a_address[4:0] are used to address the CSR registers holding 32bit each
	//for a_opcode == PuttFullData or PutPartialData we write:		
	//0->4x8Bit CSR ; 4->Address0;  8->Address1;  12->Address2;  16->Address3
	//28->cpu_go_to_idle (cpu resolves blcok)
	//for a_opcode == Get:
	//0->4x8Bit CSR ; 4->Address0;  8->Address1;  12->Address2;  16->Address3
	//20->get denied addr;  24->denied_req_type;  25->current_state;

	/////////////////////////////////
	// 		TileLink      //
	////////////////////////////////
	//Tilelink has a A-Channel (Ma->Sla) and D-Channel (Sla->Ma) lower
	//lowercase letters idicate the flow direction.
 	//Section 4.1 of TileLink Doc describes ready-valid handshanking:
	//ready-> sender must not 	 process data and sender consider not processed.
	//valid-> receiver must not expect control or data signals to be syntactially correct TileLink beat.
	//valid must(muss) never depend on ready.
	//ready should be hold low by receiver. 
	//valid must be no combinational from ready to valid, but can be.
	//Therefor we can check for device ready low and host valid transmission to find a architectural mistake
	//!!!!!!!For TileLink interface implementation we might consider pwm_reg-top of Open Titan
	//first we write PMP CSR, 4*8 Bits, each of 8 bits is described above
	
	//Verifying RANGE:
	/*
	(t ##0 tl_cpu2csr.a_address <= 32'XXXXX or
	t ##0 tl_cpu2csr.a_address >= 32'XXXXX)
	*/


	//Sequence waiting atleast 12 CLK to send ready 	
	sequence t_ready; 
		await_o(t, 1, tl_csr2cpu.a_ready, 1); 
	endsequence
	//Sequence implementing tl_pmp2h.d_* = tl_d2pmp.d_*
	sequence pmp2h_d_pass_all;
		t ##0 tl_pmp2h.d_valid == tl_d2pmp.d_valid and
		t ##0 tl_pmp2h.d_opcode == tl_d2pmp.d_opcode and
		t ##0 tl_pmp2h.d_param == tl_d2pmp.d_param and
		t ##0 tl_pmp2h.d_size == tl_d2pmp.d_size and
		t ##0 tl_pmp2h.d_source == tl_d2pmp.d_source and
		t ##0 tl_pmp2h.d_sink == tl_d2pmp.d_sink and
		t ##0 tl_pmp2h.d_data == tl_d2pmp.d_data and
		t ##0 tl_pmp2h.d_user == tl_d2pmp.d_user and
		t ##0 tl_pmp2h.d_error == tl_d2pmp.d_error;
	endsequence
	//property idea:
	//L=Lock;X=Dont Care;AA=Adress matching mode;I=Instr.;W=Write;R=Read
	// LXXA|AIWR => 1001|1111;0001|0111;1000|1000;0110|0000


	//General Assumptions:
	// We expect outputs to be set within the same CC.
	//Internal registers of the next state are set one CC later.

	//FSM DRAWING MISTAKE: state transition idle to block irq_d =1 NOT irq_q=1

	////////////////////////
	////     CPU2CSR    ////
	////////////////////////

	property check_pmp_inputs_after_cpu_write_cfg_full;
		(t ##0 tl_cpu2csr.a_opcode == PutFullData or
		t ##0 tl_cpu2csr.a_opcode == PutPartialData )and
		t ##0 tl_cpu2csr.a_address == 32'h00000000 and
		t ##0 tl_cpu2csr.a_data == 32'b10011111000101111000100001100000 and 
		t ##0 tl_cpu2csr.a_source == 8'h00 and
		t ##0 tl_cpu2csr.a_valid == 1'b1 and
		t ##0 tl_cpu2csr.a_size == 2'b10 and
		t ##0 tl_cpu2csr.a_mask == 4'b1111 and
		t ##0 tl_csr2cpu.a_ready == 1'b1
		
		implies 

		//csr_pmp_cfg is struct of ibex_pkg::pmp_cfg_t
		// Order {cfg3,cfg2,cfg1,cfg0}
		//Check if the cfg writting works
		t ##0 wr_en_csr[0] == 1'b1 and
		t ##1 tl_csr2cpu.a_ready == 1'b0 and //Hold for 0 , clearify if GET and PUT at the same time are allowed.
		t ##1 csr_pmp_cfg[3].lock == 1'b1 and
		t ##1 csr_pmp_cfg[2].lock == 1'b0 and
		t ##1 csr_pmp_cfg[1].lock == 1'b1 and
		t ##1 csr_pmp_cfg[0].lock == 1'b0 and
		t ##1 csr_pmp_cfg[3].mode == PMP_MODE_NAPOT and
		t ##1 csr_pmp_cfg[2].mode == PMP_MODE_NA4 and
		t ##1 csr_pmp_cfg[1].mode == PMP_MODE_TOR and
		t ##1 csr_pmp_cfg[0].mode == PMP_MODE_OFF and
		t ##1 csr_pmp_cfg[3].exec == 1'b1 and
		t ##1 csr_pmp_cfg[2].exec == 1'b1 and
		t ##1 csr_pmp_cfg[1].exec == 1'b0 and
		t ##1 csr_pmp_cfg[0].exec == 1'b0 and
		t ##1 csr_pmp_cfg[3].write == 1'b1 and
		t ##1 csr_pmp_cfg[2].write == 1'b1 and
		t ##1 csr_pmp_cfg[1].write == 1'b0 and
		t ##1 csr_pmp_cfg[0].write == 1'b0 and
		t ##1 csr_pmp_cfg[3].read == 1'b1 and
		t ##1 csr_pmp_cfg[2].read == 1'b1 and
		t ##1 csr_pmp_cfg[1].read == 1'b0 and
		t ##1 csr_pmp_cfg[0].read == 1'b0;
	endproperty


	
	property check_pmp_inputs_after_cpu_write_address0_full;
		(t ##0 tl_cpu2csr.a_opcode == PutFullData or
		t ##0 tl_cpu2csr.a_opcode == PutPartialData) and
		t ##0 tl_cpu2csr.a_address == 32'h00000004 and
		t ##0 tl_cpu2csr.a_data == 32'b11111111111111111111111111110000 and 
		t ##0 tl_cpu2csr.a_source == 8'h00 and
		t ##0 tl_cpu2csr.a_valid == 1'b1 and
		t ##0 tl_cpu2csr.a_size == 2'b10 and
		t ##0 tl_cpu2csr.a_mask == 4'b1111 and
		t ##0 tl_csr2cpu.a_ready == 1'b1 
		implies
		t ##1 rd_data_csr[1] == 32'b11111111111111111111111111110000;
	endproperty

	property check_pmp_inputs_after_cpu_write_address1_full;

		(t ##0 tl_cpu2csr.a_opcode == PutFullData or
		t ##0 tl_cpu2csr.a_opcode == PutPartialData) and
		t ##0 tl_cpu2csr.a_address == 32'h00000008 and
		t ##0 tl_cpu2csr.a_data == 32'b11111111111111111111111111000000 and 
		t ##0 tl_cpu2csr.a_source == 8'h00 and
		t ##0 tl_cpu2csr.a_valid == 1'b1 and
		t ##0 tl_cpu2csr.a_size == 2'b10 and
		t ##0 tl_cpu2csr.a_mask == 4'b1111 and
		t ##0 tl_csr2cpu.a_ready == 1'b1
		implies
		t ##1 rd_data_csr[2] == 32'b11111111111111111111111111000000;
		

	endproperty

	property check_pmp_inputs_after_cpu_write_address2_full;
		(t ##0 tl_cpu2csr.a_opcode == PutFullData or
		t ##0 tl_cpu2csr.a_opcode == PutPartialData) and
		t ##0 tl_cpu2csr.a_address == 32'h0000000C and
		t ##0 tl_cpu2csr.a_data == 32'b11111111111111111111110000000000 and 
		t ##0 tl_cpu2csr.a_source == 8'h00 and
		t ##0 tl_cpu2csr.a_valid == 1'b1 and
		t ##0 tl_cpu2csr.a_size == 2'b10 and
		t ##0 tl_cpu2csr.a_mask == 4'b1111 and
		t ##0 tl_csr2cpu.a_ready == 1'b1
		implies
		t ##1 rd_data_csr[3] == 32'b11111111111111111111110000000000;

	endproperty

	property check_pmp_inputs_after_cpu_write_address3_full;
		(t ##0 tl_cpu2csr.a_opcode == PutFullData or
		t ##0 tl_cpu2csr.a_opcode == PutPartialData) and
		t ##0 tl_cpu2csr.a_address == 32'h80000010 and
		t ##0 tl_cpu2csr.a_data == 32'b11111111111111111100000000000000 and 
		t ##0 tl_cpu2csr.a_source == 8'h00 and
		t ##0 tl_cpu2csr.a_valid == 1'b1 and
		t ##0 tl_cpu2csr.a_size == 2'b10 and
		t ##0 tl_cpu2csr.a_mask == 4'b1111 and
		t ##0 tl_csr2cpu.a_ready == 1'b1
		implies
		t ##1 rd_data_csr[4] == 32'b11111111111111111100000000000000;

	endproperty

	property check_pmp_inputs_after_cpu_write_cfg_partial;
		ibex_pkg::pmp_cfg_t csr_pmp_cfg_0_freeze;
		ibex_pkg::pmp_cfg_t csr_pmp_cfg_1_freeze;
		ibex_pkg::pmp_cfg_t csr_pmp_cfg_2_freeze;
		ibex_pkg::pmp_cfg_t csr_pmp_cfg_3_freeze;
		t ##0 set_freeze(csr_pmp_cfg_0_freeze, csr_pmp_cfg[0]) and
		t ##0 set_freeze(csr_pmp_cfg_1_freeze, csr_pmp_cfg[1]) and
		t ##0 set_freeze(csr_pmp_cfg_2_freeze, csr_pmp_cfg[2]) and
		t ##0 set_freeze(csr_pmp_cfg_3_freeze, csr_pmp_cfg[3]) and
		
		t ##0 tl_cpu2csr.a_opcode == PutPartialData and
		t ##0 tl_cpu2csr.a_address == 32'h00000000 and
		t ##0 tl_cpu2csr.a_data == 32'b10011111000101111000100001100000 and 
		t ##0 tl_cpu2csr.a_source == 8'h00 and
		t ##0 tl_cpu2csr.a_valid == 1'b1 and
		t ##0 tl_cpu2csr.a_size == 2'b01 and
		t ##0 tl_cpu2csr.a_mask == 4'b0110 and
		t ##0 tl_csr2cpu.a_ready == 1'b1
		
		implies 

		//csr_pmp_cfg is struct of ibex_pkg::pmp_cfg_t
		// Order {cfg3,cfg2,cfg1,cfg0}
		//Check if the cfg writting works
		t ##0 wr_en_csr[0] == 1'b1 and 
		t ##1 tl_csr2cpu.a_ready == 1'b0 and //Hold for 0 , clearify if GET and PUT at the same time are allowed.
		t ##1 csr_pmp_cfg[0] == csr_pmp_cfg_0_freeze and
		t ##1 csr_pmp_cfg[3] == csr_pmp_cfg_3_freeze and
		t ##1 csr_pmp_cfg[2].lock == 1'b0 and
		t ##1 csr_pmp_cfg[1].lock == 1'b1 and
		t ##1 csr_pmp_cfg[2].mode == PMP_MODE_NA4 and
		t ##1 csr_pmp_cfg[1].mode == PMP_MODE_TOR and
		t ##1 csr_pmp_cfg[2].exec == 1'b1 and
		t ##1 csr_pmp_cfg[1].exec == 1'b0 and
		t ##1 csr_pmp_cfg[2].write == 1'b1 and
		t ##1 csr_pmp_cfg[1].write == 1'b0 and
		t ##1 csr_pmp_cfg[2].read == 1'b1 and
		t ##1 csr_pmp_cfg[1].read == 1'b0;
	endproperty


	/**/
	property check_pmp_inputs_after_cpu_write_address0_partial;
		logic [31:0] previous_data;
		t ##0 set_freeze(previous_data, rd_data_csr[1]) and
		t ##0 tl_cpu2csr.a_opcode == PutPartialData and
		t ##0 tl_cpu2csr.a_address == 32'h00000004 and
		t ##0 tl_cpu2csr.a_data == 32'b11111111111111111111111111110000 and 
		t ##0 tl_cpu2csr.a_source == 8'h00 and
		t ##0 tl_cpu2csr.a_valid == 1'b1 and
		t ##0 tl_cpu2csr.a_size == 2'b01 and
		t ##0 tl_cpu2csr.a_mask == 4'b0011 and
		t ##0 tl_csr2cpu.a_ready == 1'b1 
		implies
		t ##1 rd_data_csr[1][31:16] == previous_data[31:16] and
		t ##1 rd_data_csr[1][15:0] == 16'b1111111111110000;
	endproperty
	/* */
	property check_pmp_inputs_after_cpu_write_address1_partial;

		logic [31:0] previous_data;
		t ##0 set_freeze(previous_data, rd_data_csr[2]) and
		t ##0 tl_cpu2csr.a_opcode == PutPartialData and
		t ##0 tl_cpu2csr.a_address == 32'h00000008 and
		t ##0 tl_cpu2csr.a_data == 32'b11111111111111111111111111110000 and 
		t ##0 tl_cpu2csr.a_source == 8'h00 and
		t ##0 tl_cpu2csr.a_valid == 1'b1 and
		t ##0 tl_cpu2csr.a_size == 2'b01 and
		t ##0 tl_cpu2csr.a_mask == 4'b0011 and
		t ##0 tl_csr2cpu.a_ready == 1'b1 
		implies
		t ##1 rd_data_csr[2][31:16] == previous_data[31:16] and
		t ##1 rd_data_csr[2][15:0] == 16'b1111111111110000;
		

	endproperty

	property check_pmp_inputs_after_cpu_write_address2_partial;
		logic [31:0] previous_data;
		t ##0 set_freeze(previous_data, rd_data_csr[3]) and
		t ##0 tl_cpu2csr.a_opcode == PutPartialData and
		t ##0 tl_cpu2csr.a_address == 32'h0000000c and
		t ##0 tl_cpu2csr.a_data == 32'b11111111111111111111111111110000 and 
		t ##0 tl_cpu2csr.a_source == 8'h00 and
		t ##0 tl_cpu2csr.a_valid == 1'b1 and
		t ##0 tl_cpu2csr.a_size == 2'b01 and
		t ##0 tl_cpu2csr.a_mask == 4'b0011 and
		t ##0 tl_csr2cpu.a_ready == 1'b1 
		implies
		t ##1 rd_data_csr[3][31:16] == previous_data[31:16] and
		t ##1 rd_data_csr[3][15:0] == 16'b1111111111110000;

	endproperty

	property check_pmp_inputs_after_cpu_write_address3_partial;
		logic [31:0] previous_data;
		t ##0 set_freeze(previous_data, rd_data_csr[4]) and
		t ##0 tl_cpu2csr.a_opcode == PutPartialData and
		t ##0 tl_cpu2csr.a_address == 32'h00000010 and
		t ##0 tl_cpu2csr.a_data == 32'b11111111111111111111111111110000 and 
		t ##0 tl_cpu2csr.a_source == 8'h00 and
		t ##0 tl_cpu2csr.a_valid == 1'b1 and
		t ##0 tl_cpu2csr.a_size == 2'b01 and
		t ##0 tl_cpu2csr.a_mask == 4'b0011 and
		t ##0 tl_csr2cpu.a_ready == 1'b1 
		implies
		t ##1 rd_data_csr[4][31:16] == previous_data[31:16] and
		t ##1 rd_data_csr[4][15:0] == 16'b1111111111110000;

	endproperty
	/**/



	property check_pmp_inputs_after_cpu_write_cfg_full_addressOR;
		
		
		//This property expect only 4 entries (5 registers) of pmp
		(t ##0 tl_cpu2csr.a_opcode == PutFullData or
		t ##0 tl_cpu2csr.a_opcode == PutPartialData) and
		//t ##0 tl_cpu2csr.a_address == 32'h000000F0 and
		t ##0 tl_cpu2csr.a_address >= 32'h00000014 and
		t ##0 tl_cpu2csr.a_address <= 32'h000003bf and
		t ##0 tl_cpu2csr.a_data == 32'b10011111000101111000100001100000 and 
		t ##0 tl_cpu2csr.a_source == 8'h00 and
		t ##0 tl_cpu2csr.a_valid == 1'b1 and
		t ##0 tl_cpu2csr.a_size == 2'b10 and
		t ##0 tl_cpu2csr.a_mask == 4'b1111 and
		t ##0 tl_csr2cpu.a_ready == 1'b1 and
		t ##1 tl_cpu2csr.d_ready == 1'b1 
		
		implies 
		t ##1 tl_csr2cpu.d_error == 1'b1 and
		t ##1 activate_cpu_err_resp_q == 1'b1 and
		t ##1 ack_outstanding_q == 1'b0;
		
	endproperty

	property upperbound_OR;
		
		
		//This property expect only 4 entries (5 registers) of pmp
		(t ##0 tl_cpu2csr.a_opcode == PutFullData or
		t ##0 tl_cpu2csr.a_opcode == PutPartialData) and
		//t ##0 tl_cpu2csr.a_address == 32'h000000F0 and
		t ##0 tl_cpu2csr.a_address <= 32'h000003FF and
		t ##0 tl_cpu2csr.a_address >= 32'h000003D0 and
		t ##0 tl_cpu2csr.a_data == 32'b10011111000101111000100001100000 and 
		t ##0 tl_cpu2csr.a_source == 8'h00 and
		t ##0 tl_cpu2csr.a_valid == 1'b1 and
		t ##0 tl_cpu2csr.a_size == 2'b10 and
		t ##0 tl_cpu2csr.a_mask == 4'b1111 and
		t ##0 tl_csr2cpu.a_ready == 1'b1 and
		t ##1 tl_cpu2csr.d_ready == 1'b1 
		
		implies 
		t ##1 tl_csr2cpu.d_error == 1'b1 and
		t ##1 activate_cpu_err_resp_q == 1'b1 and
		t ##1 ack_outstanding_q == 1'b0;
		
	endproperty







	property set_go_to_idle;
		(t ##0 tl_cpu2csr.a_opcode == PutFullData or
		t ##0 tl_cpu2csr.a_opcode == PutPartialData) and
		t ##0 tl_cpu2csr.a_address == 32'h000003C0 and
		t ##0 tl_cpu2csr.a_data == 32'b11111111111111111111111111110000 and 
		t ##0 tl_cpu2csr.a_source == 8'h00 and
		t ##0 tl_cpu2csr.a_valid == 1'b1 and
		t ##0 tl_cpu2csr.a_size == 2'b10 and
		t ##0 tl_cpu2csr.a_mask == 4'b1111 and
		t ##0 tl_csr2cpu.a_ready == 1'b1 
		implies
		t ##1 go_to_idle_q == 1'b1;
	endproperty
	
	////////////////////////
	////     CSR2CPU    ////
	////////////////////////
	property state_get_denied_reg_addr;
		//Holds with or without commented assertions	
		logic [31:0] denied_reg_addr_q_content;
		logic [7:0] host_source;
		t ##0 set_freeze(denied_reg_addr_q_content, denied_reg_addr_q) and
		t ##0 set_freeze(host_source, tl_cpu2csr.a_source) and
		t ##0 tl_cpu2csr.a_valid == 1'b1 and
		t ##0 tl_csr2cpu.a_ready == 1'b1 and
		t ##0 tl_cpu2csr.a_opcode == Get and
		t ##0 number_bits_a_mask == a_size_int and
		t ##0 tl_cpu2csr.a_address == 32'h000003C4 and
		t ##1 tl_cpu2csr.d_ready == 1'b1
		implies
		t ##0 ack_outstanding_d == 1'b1 and //holds
		t ##1 tl_csr2cpu.a_ready == 1'b0 and //holds
		t ##1 tl_csr2cpu.d_data == denied_reg_addr_q_content and //holds
		t ##1 tl_csr2cpu.d_valid == 1'b1 and //holds
		t ##1 tl_csr2cpu.d_opcode == 3'h1 and //holds //AccessAckData = 3'h1
		t ##1 tl_csr2cpu.d_source == host_source and //holds
		t ##1 tl_csr2cpu.d_size == 2'b10 and
		t ##1 tl_csr2cpu.d_error == 1'b0;
	endproperty
	

	property state_get_denied_reg_type;
		//Holds with or without commented assertions
		logic [2:0] denied_reg_type_q_content;
		logic [7:0] host_source;
		t ##0 set_freeze(denied_reg_type_q_content, denied_reg_type_q) and
		t ##0 set_freeze(host_source, tl_cpu2csr.a_source) and
		t ##0 tl_cpu2csr.a_valid == 1'b1 and
		t ##0 tl_csr2cpu.a_ready == 1'b1 and
		t ##0 tl_cpu2csr.a_opcode == Get and
		t ##0 number_bits_a_mask == a_size_int and
		t ##0 tl_cpu2csr.a_address == 32'h000003C8 and
		t ##1 tl_cpu2csr.d_ready == 1'b1
		implies
		t ##0 ack_outstanding_d == 1'b1 and //holds
		t ##1 tl_csr2cpu.a_ready == 1'b0 and //holds
		t ##1 tl_csr2cpu.d_data[2:0] == denied_reg_type_q_content and //holds
		t ##1 tl_csr2cpu.d_data[31:3] == 29'b0 and
		t ##1 tl_csr2cpu.d_valid == 1'b1 and //holds
		t ##1 tl_csr2cpu.d_opcode == 3'h1 and //holds //AccessAckData = 3'h1
		t ##1 tl_csr2cpu.d_source == host_source and //holds
		t ##1 tl_csr2cpu.d_size == 2'b10 and
		t ##1 tl_csr2cpu.d_error == 1'b0;
	endproperty

	property state_get_current_state;
		logic [1:0] current_state_content;
		logic [7:0] host_source;
		t ##0 set_freeze(current_state_content, current_state) and
		t ##0 set_freeze(host_source, tl_cpu2csr.a_source) and
		t ##0 tl_cpu2csr.a_valid == 1'b1 and
		t ##0 tl_csr2cpu.a_ready == 1'b1 and
		t ##0 tl_cpu2csr.a_opcode == Get and
		t ##0 number_bits_a_mask == a_size_int and
		t ##0 tl_cpu2csr.a_address == 32'h000003CC and
		t ##1 tl_cpu2csr.d_ready == 1'b1
		
		implies
		t ##0 ack_outstanding_d == 1'b1 and //holds
		t ##1 tl_csr2cpu.a_ready == 1'b0 and //holds
		t ##1 tl_csr2cpu.d_data[1:0] == current_state_content and //holds
		t ##1 tl_csr2cpu.d_data[31:2] == 30'b0 and
		t ##1 tl_csr2cpu.d_valid == 1'b1 and //holds
		t ##1 tl_csr2cpu.d_opcode == 3'h1 and //holds //AccessAckData = 3'h1
		t ##1 tl_csr2cpu.d_source == host_source and //holds
		t ##1 tl_csr2cpu.d_size == 2'b10 and
		t ##1 tl_csr2cpu.d_error == 1'b0;
	endproperty

	property state_get_pmp_config;
		//Holds with or without commented assertions
		t ##0 current_state == idle and
		t ##0 pmp_req_err == 1'b0 //and
		implies
		t ##0 tl_pmp2d == tl_h2pmp and
		t ##0 tl_pmp2h == tl_d2pmp and
		t ##1 current_state == idle;
	endproperty

	property state_get_pmp_address_1;
		//Holds with or without commented assertions
		t ##0 current_state == idle and
		t ##0 pmp_req_err == 1'b0 //and
		implies
		t ##0 tl_pmp2d == tl_h2pmp and
		t ##0 tl_pmp2h == tl_d2pmp and
		t ##1 current_state == idle;
	endproperty
	////////////////////////
	//    FSM properties   /
	////////////////////////
	property state_transition_1_to_1;
		//Holds with or without commented assertions
		t ##0 current_state == idle and
		t ##0 pmp_req_err == 1'b0 //and
		implies
		t ##0 tl_pmp2d == tl_h2pmp and
		t ##0 tl_pmp2h == tl_d2pmp and
		t ##1 current_state == idle;
	endproperty


	//Property fails if we remove d2pmp.a_ready from control wrapper.
	//For now I expect it as mandatory.
	property state_transition_1_to_2;
		t ##0 current_state == idle and
		//t ##0 err_rsp_sent_q == 1'b0 and
		//t ##0 go_to_idle_q == 1'b0 and
		t ##0 pmp_req_err == 1'b1 and
		t ##0 tl_h2pmp.a_valid == 1'b1 and
		t ##0 tl_d2pmp.a_ready == 1'b1 and
		t ##0 cpu_addr_rel ==  '0
		implies
		
		t ##0 tl_pmp2d.a_valid == 1'b0 and
		//h2pmp shouldn't be passed through if we go to blocking state
		t ##0 tl_pmp2d.d_ready == tl_h2pmp.d_ready and
		//devices to host -> a_ready, diff from spec 
		pmp2h_d_pass_all and
		t ##0 tl_pmp2h.a_ready == 1'b1 and
		//t ##1 tl_pmp2h.d_error = 1'b1 and
		//t ##1 err_rsp_sent_q == 1'b0 and
		//t ##1 go_to_idle_q == 1'b0 and
		t ##0 irq_d == 1'b1 and
		t ##1 current_state == block_start;
	endproperty

	property state_transition_2_to_2;
		t ##0 current_state == block_start and
		//t ##0 err_rsp_sent_q == 1'b0 and
		//t ##0 go_to_idle_q == 1'b0 and
		t ##0 tl_h2pmp.d_ready == 1'b0 and
		t ##0 go_to_idle_d == 1'b0
		//t ##0 cpu_addr_rel ==  '0
		implies
		//error of pmp2h is always 1 CC later (Error rsp unit behviour)
		t ##1 current_state == block_start and //Holds
		//t ##1 err_rsp_sent_q == 1'b0 and
		//t ##1 go_to_idle_q == 1'b0 and
		t ##0 tl_pmp2d.a_valid == 1'b0 and //Holds
		t ##0 tl_pmp2d.d_ready == 1'b0 and //Holds
		t ##0 tl_pmp2h.d_valid == 1'b1 and //Holds
		t ##0 tl_pmp2h.d_error == 1'b1 and //Fails
		//t ##0 tl_pmp2h.d_source == tl_err_rsp_device_outstanding.d_source and //Holds
		t ##0 tl_pmp2h.a_ready == 1'b0; //Fails
	endproperty

	property state_transition_2_to_3;
		t ##0 current_state == block_start and
		t ##0 tl_h2pmp.d_ready == 1'b0 and
		//t ##0 go_to_idle_d == 1'b1 and
		//t ##0 err_rsp_sent_q == 1'b0 and
		t ##0 go_to_idle_d == 1'b1
		implies
		t ##1 current_state == block_idle and //hold
		t ##0 tl_pmp2d.a_valid == 1'b0 and //holds
		t ##0 tl_pmp2d.d_ready == 1'b0 and //holds
		t ##0 tl_pmp2h.d_error == 1'b1 and //fails
		t ##0 tl_pmp2h.d_valid == 1'b1 and //holds
		//t ##0 tl_pmp2h.d_source == tl_err_rsp_device_outstanding.d_source and
		t ##0 tl_pmp2h.a_ready == 1'b0; //holds
		//t ##0 err_rsp_sent_q == 1'b0 and
		//t ##0 go_to_idle_q == 1'b1;// and
		//t ##0 irq_q == 1'b1;
	endproperty
	property state_transition_2_to_1;
		t ##0 current_state == block_start and
		t ##0 go_to_idle_d == 1'b1 and
		t ##0 tl_h2pmp.d_ready == 1'b1
		implies
		t ##0 tl_pmp2d.a_valid == 1'b0 and //holds
		t ##0 tl_pmp2d.d_ready == 1'b0 and //holds
		t ##0 tl_pmp2h.d_error == 1'b1 and //fails
		t ##0 tl_pmp2h.d_valid == 1'b1 and //holds
		t ##0 tl_pmp2h.a_ready == 1'b0 and //holds
		t ##1 current_state == idle;
	endproperty
	//write induction properties to prove source
	property state_transition_2_to_4;
		t ##0 current_state == block_start and
		t ##0 tl_h2pmp.d_ready == 1'b1 and
		t ##0 go_to_idle_d == 1'b0
		//t ##0 err_rsp_sent_q == 1'b0 and
		//t ##0 go_to_idle_q == 1'b0
		implies
		t ##0 tl_pmp2d.a_valid == 1'b0 and //holds
		t ##0 tl_pmp2d.d_ready == 1'b0 and //holds
		t ##0 tl_pmp2h.d_valid == 1'b1 and //holds
		t ##0 tl_pmp2h.d_error == 1'b1 and //holds
		//t ##1 tl_pmp2h.d_source == 1'b1 and
		t ##0 tl_pmp2h.a_ready == 1'b0 and
		t ##1 current_state == block_err;
		//t ##1 err_rsp_sent_q == 1'b1 and
		//t ##1 go_to_idle_q == 1'b0;
	endproperty
	
	property state_transition_3_to_3;
		t ##0 current_state == block_idle and
		t ##0 tl_h2pmp.d_ready == 1'b0 //and
		//t ##0 err_rsp_sent_q == 1'b0 and
		//t ##0 go_to_idle_q == 1'b1
		implies
		t ##0 tl_pmp2d.a_valid == 1'b0 and
		t ##0 tl_pmp2d.d_ready == 1'b0 and
		t ##0 tl_pmp2h.d_valid == 1'b1 and
		t ##0 tl_pmp2h.d_error == 1'b1 and
		t ##1 current_state == block_idle;// and
		//t ##1 err_rsp_sent_q == 1'b0 and
		//t ##1 go_to_idle_q == 1'b1;
	endproperty

	property state_transition_3_to_1;
		t ##0 current_state == block_idle and
		t ##0 tl_h2pmp.d_ready == 1'b1 //and
		//t ##0 err_rsp_sent_q == 1'b0 and
		//t ##0 go_to_idle_q == 1'b1
		implies
		t ##0 tl_pmp2d.a_valid == 1'b0 and
		t ##0 tl_pmp2d.d_ready == 1'b0 and
		t ##0 tl_pmp2h.d_valid == 1'b1 and
		t ##0 tl_pmp2h.d_error == 1'b1 and
		t ##0 tl_pmp2h.a_ready == 1'b0 and
		//t ##0 tl_pmp2h.source == 1'b1 and
		t ##1 current_state == idle;
		//t ##1 err_rsp_sent_q == 1'b0 and
		//t ##1 go_to_idle_q == 1'b0;
	endproperty

	property state_transition_4_to_4;
		t ##0 current_state == block_err and
		t ##0 go_to_idle_d == 1'b0
		//t ##0 err_rsp_sent_q == 1'b1 and
		//t ##0 go_to_idle_q == 1'b0
		implies
		t ##0 tl_pmp2d.a_valid == 1'b0 and //holds
		t ##0 tl_pmp2d.d_ready == 1'b0 and //holds
		pmp2h_d_pass_all and
		t ##0 tl_pmp2h.a_ready == 1'b0 and
		t ##1 current_state == block_err;// and
		//t ##1 err_rsp_sent_q == 1'b1 and
		//t ##1 go_to_idle_q == 1'b0;
	endproperty

	property state_transition_4_to_1;
		t ##0 current_state == block_err and
		t ##0 go_to_idle_d == 1'b1
		//t ##0 err_rsp_sent_q == 1'b1 and
		//t ##0 go_to_idle_q == 1'b0
		implies
		/*
		t ##0 tl_pmp2d.a_valid == 1'b0 and
		t ##0 tl_pmp2d.d_ready == tl_h2pmp.d_ready and
		pmp2h_d_pass_all and //holds
		t ##1 tl_pmp2h.a_ready == 1'b0 and
		*/
		t ##0 tl_pmp2d == tl_h2pmp and
		t ##0 tl_d2pmp == tl_pmp2h and
		t ##1 current_state == idle;
		//t ##1 err_rsp_sent_q == 1'b0 and
		//t ##1 go_to_idle_q == 1'b0;
	endproperty
	
	//Here we will check forbidden state transitions
	property state_transition_1_to_3_unallowed;
		t ##0 current_state == idle
		implies 
		t ##1 current_state !== block_idle;
	endproperty

	property state_transition_1_to_4_unallowed;
		t ##0 current_state == idle
		implies 
		t ##1 current_state != block_err;
	endproperty

	property state_transition_3_to_2_unallowed;
		t ##0 current_state == block_idle
		implies 
		t ##1 current_state != block_start;
	endproperty

	property state_transition_3_to_4_unallowed;
		t ##0 current_state == block_idle
		implies 
		t ##1 current_state != block_err;
	endproperty

	property state_transition_4_to_2_unallowed;
		t ##0 current_state == block_err
		implies 
		t ##1 current_state != block_start;
	endproperty
	property state_transition_4_to_3_unallowed;
		t ##0 current_state == block_err
		implies 
		t ##1 current_state != block_idle;
	endproperty	
//Let's talk about some changes.
//We might extend the FSM a bit, so we have a more common model instead of only a TUUL specific
a_check_pmp_inputs_after_cpu_write_cfg_full:  				assert property (@(posedge clk) disable iff (rst==0) check_pmp_inputs_after_cpu_write_cfg_full);
a_check_pmp_inputs_after_cpu_write_address0_full:  			assert property (@(posedge clk) disable iff (rst==0) check_pmp_inputs_after_cpu_write_address0_full);
a_check_pmp_inputs_after_cpu_write_address1_full:  			assert property (@(posedge clk) disable iff (rst==0) check_pmp_inputs_after_cpu_write_address1_full);
a_check_pmp_inputs_after_cpu_write_address2_full:  			assert property (@(posedge clk) disable iff (rst==0) check_pmp_inputs_after_cpu_write_address2_full);
a_check_pmp_inputs_after_cpu_write_address3_full:  			assert property (@(posedge clk) disable iff (rst==0) check_pmp_inputs_after_cpu_write_address3_full);
a_check_pmp_inputs_after_cpu_write_cfg_partial:				assert property (@(posedge clk) disable iff (rst==0) check_pmp_inputs_after_cpu_write_cfg_partial);
a_check_pmp_inputs_after_cpu_write_address0_partial:			assert property (@(posedge clk) disable iff (rst==0) check_pmp_inputs_after_cpu_write_address0_partial);
a_check_pmp_inputs_after_cpu_write_address1_partial:			assert property (@(posedge clk) disable iff (rst==0) check_pmp_inputs_after_cpu_write_address1_partial);
a_check_pmp_inputs_after_cpu_write_address2_partial:			assert property (@(posedge clk) disable iff (rst==0) check_pmp_inputs_after_cpu_write_address2_partial);
a_check_pmp_inputs_after_cpu_write_address3_partial:			assert property (@(posedge clk) disable iff (rst==0) check_pmp_inputs_after_cpu_write_address3_partial);
//OR:Out of Range
a_check_pmp_inputs_after_cpu_write_cfg_full_addressOR:  		assert property (@(posedge clk) disable iff (rst==0) check_pmp_inputs_after_cpu_write_cfg_full_addressOR);
a_upperbound_OR:							assert property (@(posedge clk) disable iff (rst==0) upperbound_OR);
//Go back to idle from cpu
a_set_go_to_idle:							assert property (@(posedge clk) disable iff (rst==0) set_go_to_idle);
//Check State Transitions
a_state_transition_1_to_1:						assert property (@(posedge clk) disable iff (rst==0) state_transition_1_to_1);
a_state_transition_1_to_2:						assert property (@(posedge clk) disable iff (rst==0) state_transition_1_to_2);
a_state_transition_2_to_2:						assert property (@(posedge clk) disable iff (rst==0) state_transition_2_to_2);
a_state_transition_2_to_1:						assert property (@(posedge clk) disable iff (rst==0) state_transition_2_to_1);
a_state_transition_2_to_3:						assert property (@(posedge clk) disable iff (rst==0) state_transition_2_to_3);
a_state_transition_2_to_4:						assert property (@(posedge clk) disable iff (rst==0) state_transition_2_to_4);
a_state_transition_3_to_3:						assert property (@(posedge clk) disable iff (rst==0) state_transition_3_to_3);
a_state_transition_3_to_1:						assert property (@(posedge clk) disable iff (rst==0) state_transition_3_to_1);
a_state_transition_4_to_4:						assert property (@(posedge clk) disable iff (rst==0) state_transition_4_to_4);
a_state_transition_4_to_1:						assert property (@(posedge clk) disable iff (rst==0) state_transition_4_to_1);
//forbidden state transitions
a_state_transition_1_to_3_unallowed:						assert property (@(posedge clk) disable iff (rst==0) state_transition_1_to_3_unallowed);
a_state_transition_1_to_4_unallowed:						assert property (@(posedge clk) disable iff (rst==0) state_transition_1_to_4_unallowed);
a_state_transition_3_to_2_unallowed:						assert property (@(posedge clk) disable iff (rst==0) state_transition_3_to_2_unallowed);
a_state_transition_3_to_4_unallowed:						assert property (@(posedge clk) disable iff (rst==0) state_transition_3_to_4_unallowed);
a_state_transition_4_to_2_unallowed:						assert property (@(posedge clk) disable iff (rst==0) state_transition_3_to_2_unallowed);
a_state_transition_4_to_3_unallowed:						assert property (@(posedge clk) disable iff (rst==0) state_transition_3_to_4_unallowed);
//csr2cpu interactions (TileLink GET)
a_state_get_denied_reg_addr:							assert property (@(posedge clk) disable iff (rst==0) state_get_denied_reg_addr);
a_state_get_denied_reg_type:							assert property (@(posedge clk) disable iff (rst==0) state_get_denied_reg_type);
a_state_get_current_state:							assert property (@(posedge clk) disable iff (rst==0) state_get_current_state);

`end_tda

endmodule

bind access_control_wrapper ACW_property_suite inst_ACW_property_suite(.*);
