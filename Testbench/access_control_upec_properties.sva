// Unpublished work. Copyright 2022 Siemens
// 
// File generated on Wed Dec 20 21:37:05 CET 2023 at frascati.eit.uni-kl.de by demirbas
// SVA module automatically generated by command 'create_sva_module'
// 
// 



module checker_m(
// BEGIN OSS_PORT: DO NOT EDIT THIS SECTION! IT IS AUTOMATICALLY GENERATED AND UPDATED BY COMMAND 'CREATE_SVA_MODULE'
	input rst_n,
	input clk,
	input irq_q_1,
	input irq_q_2,
	input rst,
	input struct packed {logic a_valid; logic[2:0] a_opcode; logic[2:0] a_param; logic[1:0] a_size; logic[7:0] a_source; logic[31:0] a_address; logic[3:0] a_mask; logic[31:0] a_data; struct packed {logic[4:0] rsvd; logic[3:0] instr_type; logic[6:0] cmd_intg; logic[6:0] data_intg; } a_user; logic d_ready; } tl_cpu2csr_1,
	input struct packed {logic a_valid; logic[2:0] a_opcode; logic[2:0] a_param; logic[1:0] a_size; logic[7:0] a_source; logic[31:0] a_address; logic[3:0] a_mask; logic[31:0] a_data; struct packed {logic[4:0] rsvd; logic[3:0] instr_type; logic[6:0] cmd_intg; logic[6:0] data_intg; } a_user; logic d_ready; } tl_cpu2csr_2,
	input struct packed {logic d_valid; logic[2:0] d_opcode; logic[2:0] d_param; logic[1:0] d_size; logic[7:0] d_source; logic d_sink; logic[31:0] d_data; struct packed {logic[6:0] rsp_intg; logic[6:0] data_intg; } d_user; logic d_error; logic a_ready; } tl_csr2cpu_1,
	input struct packed {logic d_valid; logic[2:0] d_opcode; logic[2:0] d_param; logic[1:0] d_size; logic[7:0] d_source; logic d_sink; logic[31:0] d_data; struct packed {logic[6:0] rsp_intg; logic[6:0] data_intg; } d_user; logic d_error; logic a_ready; } tl_csr2cpu_2,
	input struct packed {logic d_valid; logic[2:0] d_opcode; logic[2:0] d_param; logic[1:0] d_size; logic[7:0] d_source; logic d_sink; logic[31:0] d_data; struct packed {logic[6:0] rsp_intg; logic[6:0] data_intg; } d_user; logic d_error; logic a_ready; } tl_d2pmp_1,
	input struct packed {logic d_valid; logic[2:0] d_opcode; logic[2:0] d_param; logic[1:0] d_size; logic[7:0] d_source; logic d_sink; logic[31:0] d_data; struct packed {logic[6:0] rsp_intg; logic[6:0] data_intg; } d_user; logic d_error; logic a_ready; } tl_d2pmp_2,
	input struct packed {logic a_valid; logic[2:0] a_opcode; logic[2:0] a_param; logic[1:0] a_size; logic[7:0] a_source; logic[31:0] a_address; logic[3:0] a_mask; logic[31:0] a_data; struct packed {logic[4:0] rsvd; logic[3:0] instr_type; logic[6:0] cmd_intg; logic[6:0] data_intg; } a_user; logic d_ready; } tl_h2pmp_1,
	input struct packed {logic a_valid; logic[2:0] a_opcode; logic[2:0] a_param; logic[1:0] a_size; logic[7:0] a_source; logic[31:0] a_address; logic[3:0] a_mask; logic[31:0] a_data; struct packed {logic[4:0] rsvd; logic[3:0] instr_type; logic[6:0] cmd_intg; logic[6:0] data_intg; } a_user; logic d_ready; } tl_h2pmp_2,
	input struct packed {logic a_valid; logic[2:0] a_opcode; logic[2:0] a_param; logic[1:0] a_size; logic[7:0] a_source; logic[31:0] a_address; logic[3:0] a_mask; logic[31:0] a_data; struct packed {logic[4:0] rsvd; logic[3:0] instr_type; logic[6:0] cmd_intg; logic[6:0] data_intg; } a_user; logic d_ready; } tl_pmp2d_1,
	input struct packed {logic a_valid; logic[2:0] a_opcode; logic[2:0] a_param; logic[1:0] a_size; logic[7:0] a_source; logic[31:0] a_address; logic[3:0] a_mask; logic[31:0] a_data; struct packed {logic[4:0] rsvd; logic[3:0] instr_type; logic[6:0] cmd_intg; logic[6:0] data_intg; } a_user; logic d_ready; } tl_pmp2d_2,
	input struct packed {logic d_valid; logic[2:0] d_opcode; logic[2:0] d_param; logic[1:0] d_size; logic[7:0] d_source; logic d_sink; logic[31:0] d_data; struct packed {logic[6:0] rsp_intg; logic[6:0] data_intg; } d_user; logic d_error; logic a_ready; } tl_pmp2h_1,
	input struct packed {logic d_valid; logic[2:0] d_opcode; logic[2:0] d_param; logic[1:0] d_size; logic[7:0] d_source; logic d_sink; logic[31:0] d_data; struct packed {logic[6:0] rsp_intg; logic[6:0] data_intg; } d_user; logic d_error; logic a_ready; } tl_pmp2h_2
// END OSS_PORT: 18
);


default clocking default_clk @(posedge clk); endclocking

`include "tidal.sv"

`include "state_equivalence.sva"

//`include "symbolic_pmp.sv"

  sequence incoming_messages_denied;
    (U1.tl_h2pmp.a_valid == 1'b1 && U1.pmp_req_err[0] == 1'b1) &&
    (U2.tl_h2pmp.a_valid == 1'b1 && U2.pmp_req_err[0] == 1'b1);
  endsequence

  sequence outgoing_valid_low;
    U1.tl_pmp2d.a_valid == 1'b0 && U2.tl_pmp2d.a_valid == 1'b0;
  endsequence

  sequence go_to_idle_low;
    (U1.go_to_idle_q == 1'b0 && U2.go_to_idle_q == 1'b0) and 
    (U1.go_to_idle_d == 1'b0 && U2.go_to_idle_d == 1'b0);
  endsequence

  sequence equal_state_and_outgoing_valid;
    ((U1.current_state == U2.current_state) and
    (U1.tl_pmp2d.a_valid == U1.tl_pmp2d.a_valid)) or 
    (U1.current_state != U2.current_state);
  endsequence

`begin_tda(ops)

  sequence reset_sequence;
    (rst == 1'b1);
  endsequence 


  property UPEC_wrapper;

    t ## 0 state_equivalence() and 
    t ## 0 incoming_messages_denied and 
    t ## 0 (U1.tl_cpu2csr == U2.tl_cpu2csr) and 
    t ## 0 (U1.tl_d2pmp == U2.tl_d2pmp) and 
    t ## 1 (U1.tl_cpu2csr == U2.tl_cpu2csr) and 
    t ## 1 (U1.tl_d2pmp == U2.tl_d2pmp) and 
    t ## 1 (U1.tl_h2pmp == U2.tl_h2pmp) and
    t ## 2 (U1.tl_cpu2csr == U2.tl_cpu2csr) and 
    t ## 2 (U1.tl_d2pmp == U2.tl_d2pmp) and 
    t ## 2 (U1.tl_h2pmp == U2.tl_h2pmp) and 
    t ## 3 (U1.tl_cpu2csr == U2.tl_cpu2csr) and 
    t ## 3 (U1.tl_d2pmp == U2.tl_d2pmp) and 
    t ## 3 (U1.tl_h2pmp == U2.tl_h2pmp)
    implies 
    t ## 0 outgoing_valid_low and
    t ## 0 equal_state_and_outgoing_valid and
    t ## 0 state_equivalence2() and
    t ## 1 equal_state_and_outgoing_valid and
    t ## 1 state_equivalence2() and
    t ## 2 equal_state_and_outgoing_valid and
    t ## 2 state_equivalence2() and
    t ## 3 equal_state_and_outgoing_valid and  
    t ## 3 state_equivalence2(); 

  endproperty;

  property UPEC_step;
  
   t ## 0 state_equivalence2() and
   t ## 0 (U1.tl_cpu2csr == U2.tl_cpu2csr) and 
   t ## 0 (U1.tl_d2pmp == U2.tl_d2pmp) and 
   t ## 0 (U1.tl_h2pmp == U2.tl_h2pmp)
   implies
   t ## 1 state_equivalence2() and
   t ## 1 equal_state_and_outgoing_valid;

  endproperty;

  UPEC_wrapper_assert: assert property (UPEC_wrapper);
  UPEC_step_assert: assert property (UPEC_step);

`end_tda

endmodule

bind miter_top checker_m checker_inst (
// BEGIN OSS_BIND: DO NOT EDIT THIS SECTION! IT IS AUTOMATICALLY GENERATED AND UPDATED BY COMMAND 'CREATE_SVA_MODULE'
	.rst_n(rst_n),
	.clk(clk),
	.irq_q_1(irq_q_1),
	.irq_q_2(irq_q_2),
	.rst(rst),
	.tl_cpu2csr_1(tl_cpu2csr_1),
	.tl_cpu2csr_2(tl_cpu2csr_2),
	.tl_csr2cpu_1(tl_csr2cpu_1),
	.tl_csr2cpu_2(tl_csr2cpu_2),
	.tl_d2pmp_1(tl_d2pmp_1),
	.tl_d2pmp_2(tl_d2pmp_2),
	.tl_h2pmp_1(tl_h2pmp_1),
	.tl_h2pmp_2(tl_h2pmp_2),
	.tl_pmp2d_1(tl_pmp2d_1),
	.tl_pmp2d_2(tl_pmp2d_2),
	.tl_pmp2h_1(tl_pmp2h_1),
	.tl_pmp2h_2(tl_pmp2h_2)
// END OSS_BIND: 18
);

